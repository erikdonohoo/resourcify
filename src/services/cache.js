'use strict';

function removeFromLists(item, lists) {
  angular.forEach(lists, function (list) {
    if (list.indexOf(item) !== -1) list.splice(list.indexOf(item), 1);
  });
}

function ResourcifyCache() {

  function Cache (options) {
    this.$cache = {};
    this.$options = angular.extend({
      id: 'id',
      saveMethod: 'POST',
      key: ['id']
    }, options || {});
    this.$lists = {};
  }

  Cache.prototype.isCacheable = function (config) {
    return !config.noCache && !config.$force && config.method === 'GET';
  };

  Cache.prototype.add = function (item, postCall) {
    // If cache contains item, update it
    // If cache doesn't contain item, add it
    // and reset query
    var key = this.getKey(item);
    var cache = this.$cache;
    for (var i = 0; i < key.length - 1; i++) {
      if (!cache[key[i]]) cache[key[i]] = {};
      cache = cache[key[i]];
    }

    if (!cache[key[key.length - 1]]) {
      if (postCall) {
        angular.forEach(this.$lists, function (val) {
          val.$invalid = true;
        });
      }
      var that = this;
      // Self-removing function from cache
      item.$clearCache = function () {
        that.remove(that.getKey(this));
      }.bind(item);
      return cache[key[key.length - 1]] = item;
    } else {
      // Need to update references in other arrays
      // extends doesn't copy
      angular.extend(cache[key[key.length - 1]], item);
      return cache[key[key.length - 1]];
    }
  };

  Cache.prototype.getKey = function (obj) {
    var key = [];
    var keyConfig = angular.isArray(this.$options.key) ? this.$options.key : [this.$options.key];
    keyConfig.forEach(function (keyPiece) {
      key.push(obj[keyPiece]);
    });
    return key;
  };

  Cache.prototype.remove = function (key) {
    if (!angular.isArray(key)) {
      key = [key];
    }
    var cache = this.$cache;
    for (var i = 0; i < key.length - 1; i++) {
      cache = cache[key[i]];
    }

    var item = cache[key[key.length - 1]];
    removeFromLists(item, this.$lists);
    delete cache[key[key.length - 1]];
  };

  Cache.prototype.clear = function () {
    this.$cache = {};
    this.$lists = {};
  };

  Cache.prototype.get = function (key) {
    if (!angular.isArray(key)) {
      key = [key];
    }
    var cache = this.$cache;
    for (var i = 0; i < key.length - 1; i++) {
      cache = cache[key[i]];
    }
    return cache[key[key.length - 1]];
  };

  Cache.prototype.getList = function (key) {
    return this.$lists[key] ? this.$lists[key] : null;
  };

  Cache.prototype.addItemToList = function (list, item) {

    if (!this.get(this.getKey(item))) {
      item = this.add(item);
      list.push(item);
    } else {
      item = this.add(item);
      var match = false;
      for (var i = 0; i < list.length; i++) {
        if (item === list[i] || angular.equals(this.getKey(item), this.getKey(list[i]))) {
          match = true;
          break;
        }
      }

      if (!match) list.push(item);
    }
  };

  Cache.prototype.addList = function (key, list) {
    if (!this.$lists[key]) {
      this.$lists[key] = list;
      for (var i = 0; i < list.length; i++) {
        list[i] = this.add(list[i]);
      }
    } else {
      // Merge lists, add new values to cache
      angular.forEach(list, function (newItem) {
        var match = false;
        newItem = this.add(newItem);
        angular.forEach(this.$lists[key], function (item) {
          if (item === newItem || angular.equals(this.getKey(item), this.getKey(newItem))) {
            match = true;
          }
        }.bind(this));
        if (!match) {
          this.$lists[key].push(newItem);
        }
      }.bind(this));
    }
    return this.$lists[key];
  };

  return {
    createCache: function (options) {
      return new Cache(options);
    }
  };
}

angular.module('resourcify').factory('ResourcifyCache', ResourcifyCache);
